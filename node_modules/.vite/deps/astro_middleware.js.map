{
  "version": 3,
  "sources": ["../../cookie/index.js", "../../kleur/colors.mjs", "../../html-escaper/esm/index.js", "../../astro/dist/runtime/server/util.js", "../../astro/dist/runtime/server/escape.js", "../../astro/dist/jsx-runtime/index.js", "../../astro/dist/runtime/server/render/instruction.js", "../../astro/dist/runtime/server/hydration.js", "../../astro/dist/runtime/server/shorthash.js", "../../astro/dist/runtime/server/render/astro/head-and-content.js", "../../astro/dist/runtime/server/render/util.js", "../../astro/dist/runtime/server/render/slot.js", "../../astro/dist/runtime/server/render/common.js", "../../astro/dist/runtime/server/render/any.js", "../../astro/dist/runtime/server/render/astro/instance.js", "../../astro/dist/runtime/server/render/astro/render-template.js", "../../astro/dist/runtime/server/render/component.js", "../../astro/dist/runtime/server/jsx.js", "../../astro/dist/core/cookies/cookies.js", "../../astro/dist/core/cookies/response.js", "../../astro/dist/core/render/context.js", "../../astro/dist/core/endpoint/index.js", "../../astro/dist/core/middleware/sequence.js", "../../astro/dist/core/middleware/index.js"],
  "sourcesContent": ["/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nexports.parse = parse;\r\nexports.serialize = serialize;\r\n\r\n/**\r\n * Module variables.\r\n * @private\r\n */\r\n\r\nvar __toString = Object.prototype.toString\r\n\r\n/**\r\n * RegExp to match field-content in RFC 7230 sec 3.2\r\n *\r\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\r\n * field-vchar   = VCHAR / obs-text\r\n * obs-text      = %x80-FF\r\n */\r\n\r\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\r\n\r\n/**\r\n * Parse a cookie header.\r\n *\r\n * Parse the given cookie header string into an object\r\n * The object has the various cookies as keys(names) => values\r\n *\r\n * @param {string} str\r\n * @param {object} [options]\r\n * @return {object}\r\n * @public\r\n */\r\n\r\nfunction parse(str, options) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('argument str must be a string');\r\n  }\r\n\r\n  var obj = {}\r\n  var opt = options || {};\r\n  var dec = opt.decode || decode;\r\n\r\n  var index = 0\r\n  while (index < str.length) {\r\n    var eqIdx = str.indexOf('=', index)\r\n\r\n    // no more cookie pairs\r\n    if (eqIdx === -1) {\r\n      break\r\n    }\r\n\r\n    var endIdx = str.indexOf(';', index)\r\n\r\n    if (endIdx === -1) {\r\n      endIdx = str.length\r\n    } else if (endIdx < eqIdx) {\r\n      // backtrack on prior semicolon\r\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\r\n      continue\r\n    }\r\n\r\n    var key = str.slice(index, eqIdx).trim()\r\n\r\n    // only assign once\r\n    if (undefined === obj[key]) {\r\n      var val = str.slice(eqIdx + 1, endIdx).trim()\r\n\r\n      // quoted values\r\n      if (val.charCodeAt(0) === 0x22) {\r\n        val = val.slice(1, -1)\r\n      }\r\n\r\n      obj[key] = tryDecode(val, dec);\r\n    }\r\n\r\n    index = endIdx + 1\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Serialize data into a cookie header.\r\n *\r\n * Serialize the a name value pair into a cookie string suitable for\r\n * http headers. An optional options object specified cookie parameters.\r\n *\r\n * serialize('foo', 'bar', { httpOnly: true })\r\n *   => \"foo=bar; httpOnly\"\r\n *\r\n * @param {string} name\r\n * @param {string} val\r\n * @param {object} [options]\r\n * @return {string}\r\n * @public\r\n */\r\n\r\nfunction serialize(name, val, options) {\r\n  var opt = options || {};\r\n  var enc = opt.encode || encode;\r\n\r\n  if (typeof enc !== 'function') {\r\n    throw new TypeError('option encode is invalid');\r\n  }\r\n\r\n  if (!fieldContentRegExp.test(name)) {\r\n    throw new TypeError('argument name is invalid');\r\n  }\r\n\r\n  var value = enc(val);\r\n\r\n  if (value && !fieldContentRegExp.test(value)) {\r\n    throw new TypeError('argument val is invalid');\r\n  }\r\n\r\n  var str = name + '=' + value;\r\n\r\n  if (null != opt.maxAge) {\r\n    var maxAge = opt.maxAge - 0;\r\n\r\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\r\n      throw new TypeError('option maxAge is invalid')\r\n    }\r\n\r\n    str += '; Max-Age=' + Math.floor(maxAge);\r\n  }\r\n\r\n  if (opt.domain) {\r\n    if (!fieldContentRegExp.test(opt.domain)) {\r\n      throw new TypeError('option domain is invalid');\r\n    }\r\n\r\n    str += '; Domain=' + opt.domain;\r\n  }\r\n\r\n  if (opt.path) {\r\n    if (!fieldContentRegExp.test(opt.path)) {\r\n      throw new TypeError('option path is invalid');\r\n    }\r\n\r\n    str += '; Path=' + opt.path;\r\n  }\r\n\r\n  if (opt.expires) {\r\n    var expires = opt.expires\r\n\r\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\r\n      throw new TypeError('option expires is invalid');\r\n    }\r\n\r\n    str += '; Expires=' + expires.toUTCString()\r\n  }\r\n\r\n  if (opt.httpOnly) {\r\n    str += '; HttpOnly';\r\n  }\r\n\r\n  if (opt.secure) {\r\n    str += '; Secure';\r\n  }\r\n\r\n  if (opt.partitioned) {\r\n    str += '; Partitioned'\r\n  }\r\n\r\n  if (opt.priority) {\r\n    var priority = typeof opt.priority === 'string'\r\n      ? opt.priority.toLowerCase()\r\n      : opt.priority\r\n\r\n    switch (priority) {\r\n      case 'low':\r\n        str += '; Priority=Low'\r\n        break\r\n      case 'medium':\r\n        str += '; Priority=Medium'\r\n        break\r\n      case 'high':\r\n        str += '; Priority=High'\r\n        break\r\n      default:\r\n        throw new TypeError('option priority is invalid')\r\n    }\r\n  }\r\n\r\n  if (opt.sameSite) {\r\n    var sameSite = typeof opt.sameSite === 'string'\r\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\r\n\r\n    switch (sameSite) {\r\n      case true:\r\n        str += '; SameSite=Strict';\r\n        break;\r\n      case 'lax':\r\n        str += '; SameSite=Lax';\r\n        break;\r\n      case 'strict':\r\n        str += '; SameSite=Strict';\r\n        break;\r\n      case 'none':\r\n        str += '; SameSite=None';\r\n        break;\r\n      default:\r\n        throw new TypeError('option sameSite is invalid');\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n/**\r\n * URL-decode string value. Optimized to skip native call when no %.\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\n\r\nfunction decode (str) {\r\n  return str.indexOf('%') !== -1\r\n    ? decodeURIComponent(str)\r\n    : str\r\n}\r\n\r\n/**\r\n * URL-encode value.\r\n *\r\n * @param {string} val\r\n * @returns {string}\r\n */\r\n\r\nfunction encode (val) {\r\n  return encodeURIComponent(val)\r\n}\r\n\r\n/**\r\n * Determine if value is a Date.\r\n *\r\n * @param {*} val\r\n * @private\r\n */\r\n\r\nfunction isDate (val) {\r\n  return __toString.call(val) === '[object Date]' ||\r\n    val instanceof Date\r\n}\r\n\r\n/**\r\n * Try decoding a string using a decoding function.\r\n *\r\n * @param {string} str\r\n * @param {function} decode\r\n * @private\r\n */\r\n\r\nfunction tryDecode(str, decode) {\r\n  try {\r\n    return decode(str);\r\n  } catch (e) {\r\n    return str;\r\n  }\r\n}\r\n", "let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;\r\nif (typeof process !== 'undefined') {\r\n\t({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});\r\n\tisTTY = process.stdout && process.stdout.isTTY;\r\n}\r\n\r\nexport const $ = {\r\n\tenabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (\r\n\t\tFORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY\r\n\t)\r\n}\r\n\r\nfunction init(x, y) {\r\n\tlet rgx = new RegExp(`\\\\x1b\\\\[${y}m`, 'g');\r\n\tlet open = `\\x1b[${x}m`, close = `\\x1b[${y}m`;\r\n\r\n\treturn function (txt) {\r\n\t\tif (!$.enabled || txt == null) return txt;\r\n\t\treturn open + (!!~(''+txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;\r\n\t};\r\n}\r\n\r\n// modifiers\r\nexport const reset = init(0, 0);\r\nexport const bold = init(1, 22);\r\nexport const dim = init(2, 22);\r\nexport const italic = init(3, 23);\r\nexport const underline = init(4, 24);\r\nexport const inverse = init(7, 27);\r\nexport const hidden = init(8, 28);\r\nexport const strikethrough = init(9, 29);\r\n\r\n// colors\r\nexport const black = init(30, 39);\r\nexport const red = init(31, 39);\r\nexport const green = init(32, 39);\r\nexport const yellow = init(33, 39);\r\nexport const blue = init(34, 39);\r\nexport const magenta = init(35, 39);\r\nexport const cyan = init(36, 39);\r\nexport const white = init(37, 39);\r\nexport const gray = init(90, 39);\r\nexport const grey = init(90, 39);\r\n\r\n// background colors\r\nexport const bgBlack = init(40, 49);\r\nexport const bgRed = init(41, 49);\r\nexport const bgGreen = init(42, 49);\r\nexport const bgYellow = init(43, 49);\r\nexport const bgBlue = init(44, 49);\r\nexport const bgMagenta = init(45, 49);\r\nexport const bgCyan = init(46, 49);\r\nexport const bgWhite = init(47, 49);\r\n", "/**\r\n * Copyright (C) 2017-present by Andrea Giammarchi - @WebReflection\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\nconst {replace} = '';\r\n\r\n// escape\r\nconst es = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;\r\nconst ca = /[&<>'\"]/g;\r\n\r\nconst esca = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  \"'\": '&#39;',\r\n  '\"': '&quot;'\r\n};\r\nconst pe = m => esca[m];\r\n\r\n/**\r\n * Safely escape HTML entities such as `&`, `<`, `>`, `\"`, and `'`.\r\n * @param {string} es the input to safely escape\r\n * @returns {string} the escaped input, and it **throws** an error if\r\n *  the input type is unexpected, except for boolean and numbers,\r\n *  converted as string.\r\n */\r\nexport const escape = es => replace.call(es, ca, pe);\r\n\r\n\r\n// unescape\r\nconst unes = {\r\n  '&amp;': '&',\r\n  '&#38;': '&',\r\n  '&lt;': '<',\r\n  '&#60;': '<',\r\n  '&gt;': '>',\r\n  '&#62;': '>',\r\n  '&apos;': \"'\",\r\n  '&#39;': \"'\",\r\n  '&quot;': '\"',\r\n  '&#34;': '\"'\r\n};\r\nconst cape = m => unes[m];\r\n\r\n/**\r\n * Safely unescape previously escaped entities such as `&`, `<`, `>`, `\"`,\r\n * and `'`.\r\n * @param {string} un a previously escaped string\r\n * @returns {string} the unescaped input, and it **throws** an error if\r\n *  the input type is unexpected, except for boolean and numbers,\r\n *  converted as string.\r\n */\r\nexport const unescape = un => replace.call(un, es, cape);\r\n", "function isPromise(value) {\r\n  return !!value && typeof value === \"object\" && typeof value.then === \"function\";\r\n}\r\nasync function* streamAsyncIterator(stream) {\r\n  const reader = stream.getReader();\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done)\r\n        return;\r\n      yield value;\r\n    }\r\n  } finally {\r\n    reader.releaseLock();\r\n  }\r\n}\r\nexport {\r\n  isPromise,\r\n  streamAsyncIterator\r\n};\r\n", "import { escape } from \"html-escaper\";\r\nimport { streamAsyncIterator } from \"./util.js\";\r\nconst escapeHTML = escape;\r\nclass HTMLBytes extends Uint8Array {\r\n}\r\nObject.defineProperty(HTMLBytes.prototype, Symbol.toStringTag, {\r\n  get() {\r\n    return \"HTMLBytes\";\r\n  }\r\n});\r\nclass HTMLString extends String {\r\n  get [Symbol.toStringTag]() {\r\n    return \"HTMLString\";\r\n  }\r\n}\r\nconst markHTMLString = (value) => {\r\n  if (value instanceof HTMLString) {\r\n    return value;\r\n  }\r\n  if (typeof value === \"string\") {\r\n    return new HTMLString(value);\r\n  }\r\n  return value;\r\n};\r\nfunction isHTMLString(value) {\r\n  return Object.prototype.toString.call(value) === \"[object HTMLString]\";\r\n}\r\nfunction markHTMLBytes(bytes) {\r\n  return new HTMLBytes(bytes);\r\n}\r\nfunction isHTMLBytes(value) {\r\n  return Object.prototype.toString.call(value) === \"[object HTMLBytes]\";\r\n}\r\nfunction hasGetReader(obj) {\r\n  return typeof obj.getReader === \"function\";\r\n}\r\nasync function* unescapeChunksAsync(iterable) {\r\n  if (hasGetReader(iterable)) {\r\n    for await (const chunk of streamAsyncIterator(iterable)) {\r\n      yield unescapeHTML(chunk);\r\n    }\r\n  } else {\r\n    for await (const chunk of iterable) {\r\n      yield unescapeHTML(chunk);\r\n    }\r\n  }\r\n}\r\nfunction* unescapeChunks(iterable) {\r\n  for (const chunk of iterable) {\r\n    yield unescapeHTML(chunk);\r\n  }\r\n}\r\nfunction unescapeHTML(str) {\r\n  if (!!str && typeof str === \"object\") {\r\n    if (str instanceof Uint8Array) {\r\n      return markHTMLBytes(str);\r\n    } else if (str instanceof Response && str.body) {\r\n      const body = str.body;\r\n      return unescapeChunksAsync(body);\r\n    } else if (typeof str.then === \"function\") {\r\n      return Promise.resolve(str).then((value) => {\r\n        return unescapeHTML(value);\r\n      });\r\n    } else if (Symbol.iterator in str) {\r\n      return unescapeChunks(str);\r\n    } else if (Symbol.asyncIterator in str || hasGetReader(str)) {\r\n      return unescapeChunksAsync(str);\r\n    }\r\n  }\r\n  return markHTMLString(str);\r\n}\r\nexport {\r\n  HTMLBytes,\r\n  HTMLString,\r\n  escapeHTML,\r\n  isHTMLBytes,\r\n  isHTMLString,\r\n  markHTMLString,\r\n  unescapeHTML\r\n};\r\n", "import { Fragment, markHTMLString, Renderer } from \"../runtime/server/index.js\";\r\nconst AstroJSX = \"astro:jsx\";\r\nconst Empty = Symbol(\"empty\");\r\nconst toSlotName = (slotAttr) => slotAttr;\r\nfunction isVNode(vnode) {\r\n  return vnode && typeof vnode === \"object\" && vnode[AstroJSX];\r\n}\r\nfunction transformSlots(vnode) {\r\n  if (typeof vnode.type === \"string\")\r\n    return vnode;\r\n  const slots = {};\r\n  if (isVNode(vnode.props.children)) {\r\n    const child = vnode.props.children;\r\n    if (!isVNode(child))\r\n      return;\r\n    if (!(\"slot\" in child.props))\r\n      return;\r\n    const name = toSlotName(child.props.slot);\r\n    slots[name] = [child];\r\n    slots[name][\"$$slot\"] = true;\r\n    delete child.props.slot;\r\n    delete vnode.props.children;\r\n  }\r\n  if (Array.isArray(vnode.props.children)) {\r\n    vnode.props.children = vnode.props.children.map((child) => {\r\n      if (!isVNode(child))\r\n        return child;\r\n      if (!(\"slot\" in child.props))\r\n        return child;\r\n      const name = toSlotName(child.props.slot);\r\n      if (Array.isArray(slots[name])) {\r\n        slots[name].push(child);\r\n      } else {\r\n        slots[name] = [child];\r\n        slots[name][\"$$slot\"] = true;\r\n      }\r\n      delete child.props.slot;\r\n      return Empty;\r\n    }).filter((v) => v !== Empty);\r\n  }\r\n  Object.assign(vnode.props, slots);\r\n}\r\nfunction markRawChildren(child) {\r\n  if (typeof child === \"string\")\r\n    return markHTMLString(child);\r\n  if (Array.isArray(child))\r\n    return child.map((c) => markRawChildren(c));\r\n  return child;\r\n}\r\nfunction transformSetDirectives(vnode) {\r\n  if (!(\"set:html\" in vnode.props || \"set:text\" in vnode.props))\r\n    return;\r\n  if (\"set:html\" in vnode.props) {\r\n    const children = markRawChildren(vnode.props[\"set:html\"]);\r\n    delete vnode.props[\"set:html\"];\r\n    Object.assign(vnode.props, { children });\r\n    return;\r\n  }\r\n  if (\"set:text\" in vnode.props) {\r\n    const children = vnode.props[\"set:text\"];\r\n    delete vnode.props[\"set:text\"];\r\n    Object.assign(vnode.props, { children });\r\n    return;\r\n  }\r\n}\r\nfunction createVNode(type, props) {\r\n  const vnode = {\r\n    [Renderer]: \"astro:jsx\",\r\n    [AstroJSX]: true,\r\n    type,\r\n    props: props ?? {}\r\n  };\r\n  transformSetDirectives(vnode);\r\n  transformSlots(vnode);\r\n  return vnode;\r\n}\r\nexport {\r\n  AstroJSX,\r\n  Fragment,\r\n  isVNode,\r\n  createVNode as jsx,\r\n  createVNode as jsxDEV,\r\n  createVNode as jsxs,\r\n  transformSlots\r\n};\r\n", "const RenderInstructionSymbol = Symbol.for(\"astro:render\");\r\nfunction createRenderInstruction(instruction) {\r\n  return Object.defineProperty(instruction, RenderInstructionSymbol, {\r\n    value: true\r\n  });\r\n}\r\nfunction isRenderInstruction(chunk) {\r\n  return chunk && typeof chunk === \"object\" && chunk[RenderInstructionSymbol];\r\n}\r\nexport {\r\n  createRenderInstruction,\r\n  isRenderInstruction\r\n};\r\n", "import { AstroError, AstroErrorData } from \"../../core/errors/index.js\";\r\nimport { escapeHTML } from \"./escape.js\";\r\nimport { serializeProps } from \"./serialize.js\";\r\nconst transitionDirectivesToCopyOnIsland = Object.freeze([\r\n  \"data-astro-transition-scope\",\r\n  \"data-astro-transition-persist\"\r\n]);\r\nfunction extractDirectives(inputProps, clientDirectives) {\r\n  let extracted = {\r\n    isPage: false,\r\n    hydration: null,\r\n    props: {},\r\n    propsWithoutTransitionAttributes: {}\r\n  };\r\n  for (const [key, value] of Object.entries(inputProps)) {\r\n    if (key.startsWith(\"server:\")) {\r\n      if (key === \"server:root\") {\r\n        extracted.isPage = true;\r\n      }\r\n    }\r\n    if (key.startsWith(\"client:\")) {\r\n      if (!extracted.hydration) {\r\n        extracted.hydration = {\r\n          directive: \"\",\r\n          value: \"\",\r\n          componentUrl: \"\",\r\n          componentExport: { value: \"\" }\r\n        };\r\n      }\r\n      switch (key) {\r\n        case \"client:component-path\": {\r\n          extracted.hydration.componentUrl = value;\r\n          break;\r\n        }\r\n        case \"client:component-export\": {\r\n          extracted.hydration.componentExport.value = value;\r\n          break;\r\n        }\r\n        case \"client:component-hydration\": {\r\n          break;\r\n        }\r\n        case \"client:display-name\": {\r\n          break;\r\n        }\r\n        default: {\r\n          extracted.hydration.directive = key.split(\":\")[1];\r\n          extracted.hydration.value = value;\r\n          if (!clientDirectives.has(extracted.hydration.directive)) {\r\n            const hydrationMethods = Array.from(clientDirectives.keys()).map((d) => `client:${d}`).join(\", \");\r\n            throw new Error(\r\n              `Error: invalid hydration directive \"${key}\". Supported hydration methods: ${hydrationMethods}`\r\n            );\r\n          }\r\n          if (extracted.hydration.directive === \"media\" && typeof extracted.hydration.value !== \"string\") {\r\n            throw new AstroError(AstroErrorData.MissingMediaQueryDirective);\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      extracted.props[key] = value;\r\n      if (!transitionDirectivesToCopyOnIsland.includes(key)) {\r\n        extracted.propsWithoutTransitionAttributes[key] = value;\r\n      }\r\n    }\r\n  }\r\n  for (const sym of Object.getOwnPropertySymbols(inputProps)) {\r\n    extracted.props[sym] = inputProps[sym];\r\n    extracted.propsWithoutTransitionAttributes[sym] = inputProps[sym];\r\n  }\r\n  return extracted;\r\n}\r\nasync function generateHydrateScript(scriptOptions, metadata) {\r\n  const { renderer, result, astroId, props, attrs } = scriptOptions;\r\n  const { hydrate, componentUrl, componentExport } = metadata;\r\n  if (!componentExport.value) {\r\n    throw new AstroError({\r\n      ...AstroErrorData.NoMatchingImport,\r\n      message: AstroErrorData.NoMatchingImport.message(metadata.displayName)\r\n    });\r\n  }\r\n  const island = {\r\n    children: \"\",\r\n    props: {\r\n      // This is for HMR, probably can avoid it in prod\r\n      uid: astroId\r\n    }\r\n  };\r\n  if (attrs) {\r\n    for (const [key, value] of Object.entries(attrs)) {\r\n      island.props[key] = escapeHTML(value);\r\n    }\r\n  }\r\n  island.props[\"component-url\"] = await result.resolve(decodeURI(componentUrl));\r\n  if (renderer.clientEntrypoint) {\r\n    island.props[\"component-export\"] = componentExport.value;\r\n    island.props[\"renderer-url\"] = await result.resolve(decodeURI(renderer.clientEntrypoint));\r\n    island.props[\"props\"] = escapeHTML(serializeProps(props, metadata));\r\n  }\r\n  island.props[\"ssr\"] = \"\";\r\n  island.props[\"client\"] = hydrate;\r\n  let beforeHydrationUrl = await result.resolve(\"astro:scripts/before-hydration.js\");\r\n  if (beforeHydrationUrl.length) {\r\n    island.props[\"before-hydration-url\"] = beforeHydrationUrl;\r\n  }\r\n  island.props[\"opts\"] = escapeHTML(\r\n    JSON.stringify({\r\n      name: metadata.displayName,\r\n      value: metadata.hydrateArgs || \"\"\r\n    })\r\n  );\r\n  transitionDirectivesToCopyOnIsland.forEach((name) => {\r\n    if (props[name]) {\r\n      island.props[name] = props[name];\r\n    }\r\n  });\r\n  return island;\r\n}\r\nexport {\r\n  extractDirectives,\r\n  generateHydrateScript\r\n};\r\n", "/**\r\n * shortdash - https://github.com/bibig/node-shorthash\r\n *\r\n * @license\r\n *\r\n * (The MIT License)\r\n *\r\n * Copyright (c) 2013 Bibig <bibig@me.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\nconst dictionary = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\";\r\nconst binary = dictionary.length;\r\nfunction bitwise(str) {\r\n  let hash = 0;\r\n  if (str.length === 0)\r\n    return hash;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const ch = str.charCodeAt(i);\r\n    hash = (hash << 5) - hash + ch;\r\n    hash = hash & hash;\r\n  }\r\n  return hash;\r\n}\r\nfunction shorthash(text) {\r\n  let num;\r\n  let result = \"\";\r\n  let integer = bitwise(text);\r\n  const sign = integer < 0 ? \"Z\" : \"\";\r\n  integer = Math.abs(integer);\r\n  while (integer >= binary) {\r\n    num = integer % binary;\r\n    integer = Math.floor(integer / binary);\r\n    result = dictionary[num] + result;\r\n  }\r\n  if (integer > 0) {\r\n    result = dictionary[integer] + result;\r\n  }\r\n  return sign + result;\r\n}\r\nexport {\r\n  shorthash\r\n};\r\n", "const headAndContentSym = Symbol.for(\"astro.headAndContent\");\r\nfunction isHeadAndContent(obj) {\r\n  return typeof obj === \"object\" && !!obj[headAndContentSym];\r\n}\r\nfunction createHeadAndContent(head, content) {\r\n  return {\r\n    [headAndContentSym]: true,\r\n    head,\r\n    content\r\n  };\r\n}\r\nexport {\r\n  createHeadAndContent,\r\n  isHeadAndContent\r\n};\r\n", "import { clsx } from \"clsx\";\r\nimport { HTMLString, markHTMLString } from \"../escape.js\";\r\nconst voidElementNames = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\r\nconst htmlBooleanAttributes = /^(allowfullscreen|async|autofocus|autoplay|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|itemscope)$/i;\r\nconst htmlEnumAttributes = /^(contenteditable|draggable|spellcheck|value)$/i;\r\nconst svgEnumAttributes = /^(autoReverse|externalResourcesRequired|focusable|preserveAlpha)$/i;\r\nconst STATIC_DIRECTIVES = /* @__PURE__ */ new Set([\"set:html\", \"set:text\"]);\r\nconst toIdent = (k) => k.trim().replace(/(?:(?!^)\\b\\w|\\s+|[^\\w]+)/g, (match, index) => {\r\n  if (/[^\\w]|\\s/.test(match))\r\n    return \"\";\r\n  return index === 0 ? match : match.toUpperCase();\r\n});\r\nconst toAttributeString = (value, shouldEscape = true) => shouldEscape ? String(value).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\") : value;\r\nconst kebab = (k) => k.toLowerCase() === k ? k : k.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\r\nconst toStyleString = (obj) => Object.entries(obj).filter(([k, v]) => typeof v === \"string\" && v.trim() || typeof v === \"number\").map(([k, v]) => {\r\n  if (k[0] !== \"-\" && k[1] !== \"-\")\r\n    return `${kebab(k)}:${v}`;\r\n  return `${k}:${v}`;\r\n}).join(\";\");\r\nfunction defineScriptVars(vars) {\r\n  let output = \"\";\r\n  for (const [key, value] of Object.entries(vars)) {\r\n    output += `const ${toIdent(key)} = ${JSON.stringify(value)?.replace(\r\n      /<\\/script>/g,\r\n      \"\\\\x3C/script>\"\r\n    )};\r\n`;\r\n  }\r\n  return markHTMLString(output);\r\n}\r\nfunction formatList(values) {\r\n  if (values.length === 1) {\r\n    return values[0];\r\n  }\r\n  return `${values.slice(0, -1).join(\", \")} or ${values[values.length - 1]}`;\r\n}\r\nfunction addAttribute(value, key, shouldEscape = true) {\r\n  if (value == null) {\r\n    return \"\";\r\n  }\r\n  if (value === false) {\r\n    if (htmlEnumAttributes.test(key) || svgEnumAttributes.test(key)) {\r\n      return markHTMLString(` ${key}=\"false\"`);\r\n    }\r\n    return \"\";\r\n  }\r\n  if (STATIC_DIRECTIVES.has(key)) {\r\n    console.warn(`[astro] The \"${key}\" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.\r\n\r\nMake sure to use the static attribute syntax (\\`${key}={value}\\`) instead of the dynamic spread syntax (\\`{...{ \"${key}\": value }}\\`).`);\r\n    return \"\";\r\n  }\r\n  if (key === \"class:list\") {\r\n    const listValue = toAttributeString(clsx(value), shouldEscape);\r\n    if (listValue === \"\") {\r\n      return \"\";\r\n    }\r\n    return markHTMLString(` ${key.slice(0, -5)}=\"${listValue}\"`);\r\n  }\r\n  if (key === \"style\" && !(value instanceof HTMLString)) {\r\n    if (Array.isArray(value) && value.length === 2) {\r\n      return markHTMLString(\r\n        ` ${key}=\"${toAttributeString(`${toStyleString(value[0])};${value[1]}`, shouldEscape)}\"`\r\n      );\r\n    }\r\n    if (typeof value === \"object\") {\r\n      return markHTMLString(` ${key}=\"${toAttributeString(toStyleString(value), shouldEscape)}\"`);\r\n    }\r\n  }\r\n  if (key === \"className\") {\r\n    return markHTMLString(` class=\"${toAttributeString(value, shouldEscape)}\"`);\r\n  }\r\n  if (value === true && (key.startsWith(\"data-\") || htmlBooleanAttributes.test(key))) {\r\n    return markHTMLString(` ${key}`);\r\n  } else {\r\n    return markHTMLString(` ${key}=\"${toAttributeString(value, shouldEscape)}\"`);\r\n  }\r\n}\r\nfunction internalSpreadAttributes(values, shouldEscape = true) {\r\n  let output = \"\";\r\n  for (const [key, value] of Object.entries(values)) {\r\n    output += addAttribute(value, key, shouldEscape);\r\n  }\r\n  return markHTMLString(output);\r\n}\r\nfunction renderElement(name, { props: _props, children = \"\" }, shouldEscape = true) {\r\n  const { lang: _, \"data-astro-id\": astroId, \"define:vars\": defineVars, ...props } = _props;\r\n  if (defineVars) {\r\n    if (name === \"style\") {\r\n      delete props[\"is:global\"];\r\n      delete props[\"is:scoped\"];\r\n    }\r\n    if (name === \"script\") {\r\n      delete props.hoist;\r\n      children = defineScriptVars(defineVars) + \"\\n\" + children;\r\n    }\r\n  }\r\n  if ((children == null || children == \"\") && voidElementNames.test(name)) {\r\n    return `<${name}${internalSpreadAttributes(props, shouldEscape)} />`;\r\n  }\r\n  return `<${name}${internalSpreadAttributes(props, shouldEscape)}>${children}</${name}>`;\r\n}\r\nfunction renderToBufferDestination(bufferRenderFunction) {\r\n  const bufferChunks = [];\r\n  const bufferDestination = {\r\n    write: (chunk) => bufferChunks.push(chunk)\r\n  };\r\n  const renderPromise = bufferRenderFunction(bufferDestination);\r\n  return {\r\n    async renderToFinalDestination(destination) {\r\n      for (const chunk of bufferChunks) {\r\n        destination.write(chunk);\r\n      }\r\n      bufferDestination.write = (chunk) => destination.write(chunk);\r\n      await renderPromise;\r\n    }\r\n  };\r\n}\r\nexport {\r\n  addAttribute,\r\n  defineScriptVars,\r\n  formatList,\r\n  internalSpreadAttributes,\r\n  renderElement,\r\n  renderToBufferDestination,\r\n  toAttributeString,\r\n  voidElementNames\r\n};\r\n", "import { HTMLString, markHTMLString } from \"../escape.js\";\r\nimport { renderChild } from \"./any.js\";\r\nimport { chunkToString } from \"./common.js\";\r\nconst slotString = Symbol.for(\"astro:slot-string\");\r\nclass SlotString extends HTMLString {\r\n  instructions;\r\n  [slotString];\r\n  constructor(content, instructions) {\r\n    super(content);\r\n    this.instructions = instructions;\r\n    this[slotString] = true;\r\n  }\r\n}\r\nfunction isSlotString(str) {\r\n  return !!str[slotString];\r\n}\r\nfunction renderSlot(result, slotted, fallback) {\r\n  if (!slotted && fallback) {\r\n    return renderSlot(result, fallback);\r\n  }\r\n  return {\r\n    async render(destination) {\r\n      await renderChild(destination, typeof slotted === \"function\" ? slotted(result) : slotted);\r\n    }\r\n  };\r\n}\r\nasync function renderSlotToString(result, slotted, fallback) {\r\n  let content = \"\";\r\n  let instructions = null;\r\n  const temporaryDestination = {\r\n    write(chunk) {\r\n      if (chunk instanceof Response)\r\n        return;\r\n      if (typeof chunk === \"object\" && \"type\" in chunk && typeof chunk.type === \"string\") {\r\n        if (instructions === null) {\r\n          instructions = [];\r\n        }\r\n        instructions.push(chunk);\r\n      } else {\r\n        content += chunkToString(result, chunk);\r\n      }\r\n    }\r\n  };\r\n  const renderInstance = renderSlot(result, slotted, fallback);\r\n  await renderInstance.render(temporaryDestination);\r\n  return markHTMLString(new SlotString(content, instructions));\r\n}\r\nasync function renderSlots(result, slots = {}) {\r\n  let slotInstructions = null;\r\n  let children = {};\r\n  if (slots) {\r\n    await Promise.all(\r\n      Object.entries(slots).map(\r\n        ([key, value]) => renderSlotToString(result, value).then((output) => {\r\n          if (output.instructions) {\r\n            if (slotInstructions === null) {\r\n              slotInstructions = [];\r\n            }\r\n            slotInstructions.push(...output.instructions);\r\n          }\r\n          children[key] = output;\r\n        })\r\n      )\r\n    );\r\n  }\r\n  return { slotInstructions, children };\r\n}\r\nexport {\r\n  SlotString,\r\n  isSlotString,\r\n  renderSlot,\r\n  renderSlotToString,\r\n  renderSlots\r\n};\r\n", "import { markHTMLString } from \"../escape.js\";\r\nimport {\r\n  determineIfNeedsHydrationScript,\r\n  determinesIfNeedsDirectiveScript,\r\n  getPrescripts\r\n} from \"../scripts.js\";\r\nimport { renderAllHeadContent } from \"./head.js\";\r\nimport { isRenderInstruction } from \"./instruction.js\";\r\nimport { isSlotString } from \"./slot.js\";\r\nconst Fragment = Symbol.for(\"astro:fragment\");\r\nconst Renderer = Symbol.for(\"astro:renderer\");\r\nconst encoder = new TextEncoder();\r\nconst decoder = new TextDecoder();\r\nfunction stringifyChunk(result, chunk) {\r\n  if (isRenderInstruction(chunk)) {\r\n    const instruction = chunk;\r\n    switch (instruction.type) {\r\n      case \"directive\": {\r\n        const { hydration } = instruction;\r\n        let needsHydrationScript = hydration && determineIfNeedsHydrationScript(result);\r\n        let needsDirectiveScript = hydration && determinesIfNeedsDirectiveScript(result, hydration.directive);\r\n        let prescriptType = needsHydrationScript ? \"both\" : needsDirectiveScript ? \"directive\" : null;\r\n        if (prescriptType) {\r\n          let prescripts = getPrescripts(result, prescriptType, hydration.directive);\r\n          return markHTMLString(prescripts);\r\n        } else {\r\n          return \"\";\r\n        }\r\n      }\r\n      case \"head\": {\r\n        if (result._metadata.hasRenderedHead || result.partial) {\r\n          return \"\";\r\n        }\r\n        return renderAllHeadContent(result);\r\n      }\r\n      case \"maybe-head\": {\r\n        if (result._metadata.hasRenderedHead || result._metadata.headInTree || result.partial) {\r\n          return \"\";\r\n        }\r\n        return renderAllHeadContent(result);\r\n      }\r\n      case \"renderer-hydration-script\": {\r\n        const { rendererSpecificHydrationScripts } = result._metadata;\r\n        const { rendererName } = instruction;\r\n        if (!rendererSpecificHydrationScripts.has(rendererName)) {\r\n          rendererSpecificHydrationScripts.add(rendererName);\r\n          return instruction.render();\r\n        }\r\n        return \"\";\r\n      }\r\n      default: {\r\n        throw new Error(`Unknown chunk type: ${chunk.type}`);\r\n      }\r\n    }\r\n  } else if (chunk instanceof Response) {\r\n    return \"\";\r\n  } else if (isSlotString(chunk)) {\r\n    let out = \"\";\r\n    const c = chunk;\r\n    if (c.instructions) {\r\n      for (const instr of c.instructions) {\r\n        out += stringifyChunk(result, instr);\r\n      }\r\n    }\r\n    out += chunk.toString();\r\n    return out;\r\n  }\r\n  return chunk.toString();\r\n}\r\nfunction chunkToString(result, chunk) {\r\n  if (ArrayBuffer.isView(chunk)) {\r\n    return decoder.decode(chunk);\r\n  } else {\r\n    return stringifyChunk(result, chunk);\r\n  }\r\n}\r\nfunction chunkToByteArray(result, chunk) {\r\n  if (ArrayBuffer.isView(chunk)) {\r\n    return chunk;\r\n  } else {\r\n    const stringified = stringifyChunk(result, chunk);\r\n    return encoder.encode(stringified.toString());\r\n  }\r\n}\r\nfunction isRenderInstance(obj) {\r\n  return !!obj && typeof obj === \"object\" && \"render\" in obj && typeof obj.render === \"function\";\r\n}\r\nexport {\r\n  Fragment,\r\n  Renderer,\r\n  chunkToByteArray,\r\n  chunkToString,\r\n  decoder,\r\n  encoder,\r\n  isRenderInstance\r\n};\r\n", "import { escapeHTML, isHTMLString, markHTMLString } from \"../escape.js\";\r\nimport { isAstroComponentInstance, isRenderTemplateResult } from \"./astro/index.js\";\r\nimport { isRenderInstance } from \"./common.js\";\r\nimport { SlotString } from \"./slot.js\";\r\nimport { renderToBufferDestination } from \"./util.js\";\r\nasync function renderChild(destination, child) {\r\n  child = await child;\r\n  if (child instanceof SlotString) {\r\n    destination.write(child);\r\n  } else if (isHTMLString(child)) {\r\n    destination.write(child);\r\n  } else if (Array.isArray(child)) {\r\n    const childRenders = child.map((c) => {\r\n      return renderToBufferDestination((bufferDestination) => {\r\n        return renderChild(bufferDestination, c);\r\n      });\r\n    });\r\n    for (const childRender of childRenders) {\r\n      if (!childRender)\r\n        continue;\r\n      await childRender.renderToFinalDestination(destination);\r\n    }\r\n  } else if (typeof child === \"function\") {\r\n    await renderChild(destination, child());\r\n  } else if (typeof child === \"string\") {\r\n    destination.write(markHTMLString(escapeHTML(child)));\r\n  } else if (!child && child !== 0) {\r\n  } else if (isRenderInstance(child)) {\r\n    await child.render(destination);\r\n  } else if (isRenderTemplateResult(child)) {\r\n    await child.render(destination);\r\n  } else if (isAstroComponentInstance(child)) {\r\n    await child.render(destination);\r\n  } else if (ArrayBuffer.isView(child)) {\r\n    destination.write(child);\r\n  } else if (typeof child === \"object\" && (Symbol.asyncIterator in child || Symbol.iterator in child)) {\r\n    for await (const value of child) {\r\n      await renderChild(destination, value);\r\n    }\r\n  } else {\r\n    destination.write(child);\r\n  }\r\n}\r\nexport {\r\n  renderChild\r\n};\r\n", "import { isPromise } from \"../../util.js\";\r\nimport { renderChild } from \"../any.js\";\r\nimport { isAPropagatingComponent } from \"./factory.js\";\r\nimport { isHeadAndContent } from \"./head-and-content.js\";\r\nconst astroComponentInstanceSym = Symbol.for(\"astro.componentInstance\");\r\nclass AstroComponentInstance {\r\n  [astroComponentInstanceSym] = true;\r\n  result;\r\n  props;\r\n  slotValues;\r\n  factory;\r\n  returnValue;\r\n  constructor(result, props, slots, factory) {\r\n    this.result = result;\r\n    this.props = props;\r\n    this.factory = factory;\r\n    this.slotValues = {};\r\n    for (const name in slots) {\r\n      let didRender = false;\r\n      let value = slots[name](result);\r\n      this.slotValues[name] = () => {\r\n        if (!didRender) {\r\n          didRender = true;\r\n          return value;\r\n        }\r\n        return slots[name](result);\r\n      };\r\n    }\r\n  }\r\n  async init(result) {\r\n    if (this.returnValue !== void 0)\r\n      return this.returnValue;\r\n    this.returnValue = this.factory(result, this.props, this.slotValues);\r\n    return this.returnValue;\r\n  }\r\n  async render(destination) {\r\n    if (this.returnValue === void 0) {\r\n      await this.init(this.result);\r\n    }\r\n    let value = this.returnValue;\r\n    if (isPromise(value)) {\r\n      value = await value;\r\n    }\r\n    if (isHeadAndContent(value)) {\r\n      await value.content.render(destination);\r\n    } else {\r\n      await renderChild(destination, value);\r\n    }\r\n  }\r\n}\r\nfunction validateComponentProps(props, displayName) {\r\n  if (props != null) {\r\n    for (const prop of Object.keys(props)) {\r\n      if (prop.startsWith(\"client:\")) {\r\n        console.warn(\r\n          `You are attempting to render <${displayName} ${prop} />, but ${displayName} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction createAstroComponentInstance(result, displayName, factory, props, slots = {}) {\r\n  validateComponentProps(props, displayName);\r\n  const instance = new AstroComponentInstance(result, props, slots, factory);\r\n  if (isAPropagatingComponent(result, factory)) {\r\n    result._metadata.propagators.add(instance);\r\n  }\r\n  return instance;\r\n}\r\nfunction isAstroComponentInstance(obj) {\r\n  return typeof obj === \"object\" && !!obj[astroComponentInstanceSym];\r\n}\r\nexport {\r\n  AstroComponentInstance,\r\n  createAstroComponentInstance,\r\n  isAstroComponentInstance\r\n};\r\n", "import { markHTMLString } from \"../../escape.js\";\r\nimport { isPromise } from \"../../util.js\";\r\nimport { renderChild } from \"../any.js\";\r\nimport { renderToBufferDestination } from \"../util.js\";\r\nconst renderTemplateResultSym = Symbol.for(\"astro.renderTemplateResult\");\r\nclass RenderTemplateResult {\r\n  [renderTemplateResultSym] = true;\r\n  htmlParts;\r\n  expressions;\r\n  error;\r\n  constructor(htmlParts, expressions) {\r\n    this.htmlParts = htmlParts;\r\n    this.error = void 0;\r\n    this.expressions = expressions.map((expression) => {\r\n      if (isPromise(expression)) {\r\n        return Promise.resolve(expression).catch((err) => {\r\n          if (!this.error) {\r\n            this.error = err;\r\n            throw err;\r\n          }\r\n        });\r\n      }\r\n      return expression;\r\n    });\r\n  }\r\n  async render(destination) {\r\n    const expRenders = this.expressions.map((exp) => {\r\n      return renderToBufferDestination((bufferDestination) => {\r\n        if (exp || exp === 0) {\r\n          return renderChild(bufferDestination, exp);\r\n        }\r\n      });\r\n    });\r\n    for (let i = 0; i < this.htmlParts.length; i++) {\r\n      const html = this.htmlParts[i];\r\n      const expRender = expRenders[i];\r\n      destination.write(markHTMLString(html));\r\n      if (expRender) {\r\n        await expRender.renderToFinalDestination(destination);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction isRenderTemplateResult(obj) {\r\n  return typeof obj === \"object\" && !!obj[renderTemplateResultSym];\r\n}\r\nfunction renderTemplate(htmlParts, ...expressions) {\r\n  return new RenderTemplateResult(htmlParts, expressions);\r\n}\r\nexport {\r\n  RenderTemplateResult,\r\n  isRenderTemplateResult,\r\n  renderTemplate\r\n};\r\n", "import { createRenderInstruction } from \"./instruction.js\";\r\nimport { clsx } from \"clsx\";\r\nimport { AstroError, AstroErrorData } from \"../../../core/errors/index.js\";\r\nimport { markHTMLString } from \"../escape.js\";\r\nimport { extractDirectives, generateHydrateScript } from \"../hydration.js\";\r\nimport { serializeProps } from \"../serialize.js\";\r\nimport { shorthash } from \"../shorthash.js\";\r\nimport { isPromise } from \"../util.js\";\r\nimport { isAstroComponentFactory } from \"./astro/factory.js\";\r\nimport { renderTemplate } from \"./astro/index.js\";\r\nimport { createAstroComponentInstance } from \"./astro/instance.js\";\r\nimport {\r\n  Fragment,\r\n  Renderer,\r\n  chunkToString\r\n} from \"./common.js\";\r\nimport { componentIsHTMLElement, renderHTMLElement } from \"./dom.js\";\r\nimport { maybeRenderHead } from \"./head.js\";\r\nimport { renderSlotToString, renderSlots } from \"./slot.js\";\r\nimport { formatList, internalSpreadAttributes, renderElement, voidElementNames } from \"./util.js\";\r\nconst needsHeadRenderingSymbol = Symbol.for(\"astro.needsHeadRendering\");\r\nconst rendererAliases = /* @__PURE__ */ new Map([[\"solid\", \"solid-js\"]]);\r\nfunction guessRenderers(componentUrl) {\r\n  const extname = componentUrl?.split(\".\").pop();\r\n  switch (extname) {\r\n    case \"svelte\":\r\n      return [\"@astrojs/svelte\"];\r\n    case \"vue\":\r\n      return [\"@astrojs/vue\"];\r\n    case \"jsx\":\r\n    case \"tsx\":\r\n      return [\"@astrojs/react\", \"@astrojs/preact\", \"@astrojs/solid-js\", \"@astrojs/vue (jsx)\"];\r\n    default:\r\n      return [\r\n        \"@astrojs/react\",\r\n        \"@astrojs/preact\",\r\n        \"@astrojs/solid-js\",\r\n        \"@astrojs/vue\",\r\n        \"@astrojs/svelte\",\r\n        \"@astrojs/lit\"\r\n      ];\r\n  }\r\n}\r\nfunction isFragmentComponent(Component) {\r\n  return Component === Fragment;\r\n}\r\nfunction isHTMLComponent(Component) {\r\n  return Component && Component[\"astro:html\"] === true;\r\n}\r\nconst ASTRO_SLOT_EXP = /\\<\\/?astro-slot\\b[^>]*>/g;\r\nconst ASTRO_STATIC_SLOT_EXP = /\\<\\/?astro-static-slot\\b[^>]*>/g;\r\nfunction removeStaticAstroSlot(html, supportsAstroStaticSlot) {\r\n  const exp = supportsAstroStaticSlot ? ASTRO_STATIC_SLOT_EXP : ASTRO_SLOT_EXP;\r\n  return html.replace(exp, \"\");\r\n}\r\nasync function renderFrameworkComponent(result, displayName, Component, _props, slots = {}) {\r\n  if (!Component && !_props[\"client:only\"]) {\r\n    throw new Error(\r\n      `Unable to render ${displayName} because it is ${Component}!\r\nDid you forget to import the component or is it possible there is a typo?`\r\n    );\r\n  }\r\n  const { renderers, clientDirectives } = result;\r\n  const metadata = {\r\n    astroStaticSlot: true,\r\n    displayName\r\n  };\r\n  const { hydration, isPage, props, propsWithoutTransitionAttributes } = extractDirectives(\r\n    _props,\r\n    clientDirectives\r\n  );\r\n  let html = \"\";\r\n  let attrs = void 0;\r\n  if (hydration) {\r\n    metadata.hydrate = hydration.directive;\r\n    metadata.hydrateArgs = hydration.value;\r\n    metadata.componentExport = hydration.componentExport;\r\n    metadata.componentUrl = hydration.componentUrl;\r\n  }\r\n  const probableRendererNames = guessRenderers(metadata.componentUrl);\r\n  const validRenderers = renderers.filter((r) => r.name !== \"astro:jsx\");\r\n  const { children, slotInstructions } = await renderSlots(result, slots);\r\n  let renderer;\r\n  if (metadata.hydrate !== \"only\") {\r\n    let isTagged = false;\r\n    try {\r\n      isTagged = Component && Component[Renderer];\r\n    } catch {\r\n    }\r\n    if (isTagged) {\r\n      const rendererName = Component[Renderer];\r\n      renderer = renderers.find(({ name }) => name === rendererName);\r\n    }\r\n    if (!renderer) {\r\n      let error;\r\n      for (const r of renderers) {\r\n        try {\r\n          if (await r.ssr.check.call({ result }, Component, props, children)) {\r\n            renderer = r;\r\n            break;\r\n          }\r\n        } catch (e) {\r\n          error ??= e;\r\n        }\r\n      }\r\n      if (!renderer && error) {\r\n        throw error;\r\n      }\r\n    }\r\n    if (!renderer && typeof HTMLElement === \"function\" && componentIsHTMLElement(Component)) {\r\n      const output = await renderHTMLElement(\r\n        result,\r\n        Component,\r\n        _props,\r\n        slots\r\n      );\r\n      return {\r\n        render(destination) {\r\n          destination.write(output);\r\n        }\r\n      };\r\n    }\r\n  } else {\r\n    if (metadata.hydrateArgs) {\r\n      const passedName = metadata.hydrateArgs;\r\n      const rendererName = rendererAliases.has(passedName) ? rendererAliases.get(passedName) : passedName;\r\n      renderer = renderers.find(\r\n        ({ name }) => name === `@astrojs/${rendererName}` || name === rendererName\r\n      );\r\n    }\r\n    if (!renderer && validRenderers.length === 1) {\r\n      renderer = validRenderers[0];\r\n    }\r\n    if (!renderer) {\r\n      const extname = metadata.componentUrl?.split(\".\").pop();\r\n      renderer = renderers.filter(\r\n        ({ name }) => name === `@astrojs/${extname}` || name === extname\r\n      )[0];\r\n    }\r\n  }\r\n  if (!renderer) {\r\n    if (metadata.hydrate === \"only\") {\r\n      throw new AstroError({\r\n        ...AstroErrorData.NoClientOnlyHint,\r\n        message: AstroErrorData.NoClientOnlyHint.message(metadata.displayName),\r\n        hint: AstroErrorData.NoClientOnlyHint.hint(\r\n          probableRendererNames.map((r) => r.replace(\"@astrojs/\", \"\")).join(\"|\")\r\n        )\r\n      });\r\n    } else if (typeof Component !== \"string\") {\r\n      const matchingRenderers = validRenderers.filter(\r\n        (r) => probableRendererNames.includes(r.name)\r\n      );\r\n      const plural = validRenderers.length > 1;\r\n      if (matchingRenderers.length === 0) {\r\n        throw new AstroError({\r\n          ...AstroErrorData.NoMatchingRenderer,\r\n          message: AstroErrorData.NoMatchingRenderer.message(\r\n            metadata.displayName,\r\n            metadata?.componentUrl?.split(\".\").pop(),\r\n            plural,\r\n            validRenderers.length\r\n          ),\r\n          hint: AstroErrorData.NoMatchingRenderer.hint(\r\n            formatList(probableRendererNames.map((r) => \"`\" + r + \"`\"))\r\n          )\r\n        });\r\n      } else if (matchingRenderers.length === 1) {\r\n        renderer = matchingRenderers[0];\r\n        ({ html, attrs } = await renderer.ssr.renderToStaticMarkup.call(\r\n          { result },\r\n          Component,\r\n          propsWithoutTransitionAttributes,\r\n          children,\r\n          metadata\r\n        ));\r\n      } else {\r\n        throw new Error(`Unable to render ${metadata.displayName}!\r\n\r\nThis component likely uses ${formatList(probableRendererNames)},\r\nbut Astro encountered an error during server-side rendering.\r\n\r\nPlease ensure that ${metadata.displayName}:\r\n1. Does not unconditionally access browser-specific globals like \\`window\\` or \\`document\\`.\r\n   If this is unavoidable, use the \\`client:only\\` hydration directive.\r\n2. Does not conditionally return \\`null\\` or \\`undefined\\` when rendered on the server.\r\n\r\nIf you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);\r\n      }\r\n    }\r\n  } else {\r\n    if (metadata.hydrate === \"only\") {\r\n      html = await renderSlotToString(result, slots?.fallback);\r\n    } else {\r\n      ({ html, attrs } = await renderer.ssr.renderToStaticMarkup.call(\r\n        { result },\r\n        Component,\r\n        propsWithoutTransitionAttributes,\r\n        children,\r\n        metadata\r\n      ));\r\n    }\r\n  }\r\n  if (renderer && !renderer.clientEntrypoint && renderer.name !== \"@astrojs/lit\" && metadata.hydrate) {\r\n    throw new AstroError({\r\n      ...AstroErrorData.NoClientEntrypoint,\r\n      message: AstroErrorData.NoClientEntrypoint.message(\r\n        displayName,\r\n        metadata.hydrate,\r\n        renderer.name\r\n      )\r\n    });\r\n  }\r\n  if (!html && typeof Component === \"string\") {\r\n    const Tag = sanitizeElementName(Component);\r\n    const childSlots = Object.values(children).join(\"\");\r\n    const renderTemplateResult = renderTemplate`<${Tag}${internalSpreadAttributes(\r\n      props\r\n    )}${markHTMLString(\r\n      childSlots === \"\" && voidElementNames.test(Tag) ? `/>` : `>${childSlots}</${Tag}>`\r\n    )}`;\r\n    html = \"\";\r\n    const destination = {\r\n      write(chunk) {\r\n        if (chunk instanceof Response)\r\n          return;\r\n        html += chunkToString(result, chunk);\r\n      }\r\n    };\r\n    await renderTemplateResult.render(destination);\r\n  }\r\n  if (!hydration) {\r\n    return {\r\n      render(destination) {\r\n        if (slotInstructions) {\r\n          for (const instruction of slotInstructions) {\r\n            destination.write(instruction);\r\n          }\r\n        }\r\n        if (isPage || renderer?.name === \"astro:jsx\") {\r\n          destination.write(html);\r\n        } else if (html && html.length > 0) {\r\n          destination.write(\r\n            markHTMLString(\r\n              removeStaticAstroSlot(html, renderer?.ssr?.supportsAstroStaticSlot ?? false)\r\n            )\r\n          );\r\n        }\r\n      }\r\n    };\r\n  }\r\n  const astroId = shorthash(\r\n    `<!--${metadata.componentExport.value}:${metadata.componentUrl}-->\r\n${html}\r\n${serializeProps(\r\n      props,\r\n      metadata\r\n    )}`\r\n  );\r\n  const island = await generateHydrateScript(\r\n    { renderer, result, astroId, props, attrs },\r\n    metadata\r\n  );\r\n  let unrenderedSlots = [];\r\n  if (html) {\r\n    if (Object.keys(children).length > 0) {\r\n      for (const key of Object.keys(children)) {\r\n        let tagName = renderer?.ssr?.supportsAstroStaticSlot ? !!metadata.hydrate ? \"astro-slot\" : \"astro-static-slot\" : \"astro-slot\";\r\n        let expectedHTML = key === \"default\" ? `<${tagName}>` : `<${tagName} name=\"${key}\">`;\r\n        if (!html.includes(expectedHTML)) {\r\n          unrenderedSlots.push(key);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    unrenderedSlots = Object.keys(children);\r\n  }\r\n  const template = unrenderedSlots.length > 0 ? unrenderedSlots.map(\r\n    (key) => `<template data-astro-template${key !== \"default\" ? `=\"${key}\"` : \"\"}>${children[key]}</template>`\r\n  ).join(\"\") : \"\";\r\n  island.children = `${html ?? \"\"}${template}`;\r\n  if (island.children) {\r\n    island.props[\"await-children\"] = \"\";\r\n    island.children += `<!--astro:end-->`;\r\n  }\r\n  return {\r\n    render(destination) {\r\n      if (slotInstructions) {\r\n        for (const instruction of slotInstructions) {\r\n          destination.write(instruction);\r\n        }\r\n      }\r\n      destination.write(createRenderInstruction({ type: \"directive\", hydration }));\r\n      if (hydration.directive !== \"only\" && renderer?.ssr.renderHydrationScript) {\r\n        destination.write(\r\n          createRenderInstruction({\r\n            type: \"renderer-hydration-script\",\r\n            rendererName: renderer.name,\r\n            render: renderer.ssr.renderHydrationScript\r\n          })\r\n        );\r\n      }\r\n      destination.write(markHTMLString(renderElement(\"astro-island\", island, false)));\r\n    }\r\n  };\r\n}\r\nfunction sanitizeElementName(tag) {\r\n  const unsafe = /[&<>'\"\\s]+/g;\r\n  if (!unsafe.test(tag))\r\n    return tag;\r\n  return tag.trim().split(unsafe)[0].trim();\r\n}\r\nasync function renderFragmentComponent(result, slots = {}) {\r\n  const children = await renderSlotToString(result, slots?.default);\r\n  return {\r\n    render(destination) {\r\n      if (children == null)\r\n        return;\r\n      destination.write(children);\r\n    }\r\n  };\r\n}\r\nasync function renderHTMLComponent(result, Component, _props, slots = {}) {\r\n  const { slotInstructions, children } = await renderSlots(result, slots);\r\n  const html = Component({ slots: children });\r\n  const hydrationHtml = slotInstructions ? slotInstructions.map((instr) => chunkToString(result, instr)).join(\"\") : \"\";\r\n  return {\r\n    render(destination) {\r\n      destination.write(markHTMLString(hydrationHtml + html));\r\n    }\r\n  };\r\n}\r\nfunction renderAstroComponent(result, displayName, Component, props, slots = {}) {\r\n  const instance = createAstroComponentInstance(result, displayName, Component, props, slots);\r\n  return {\r\n    async render(destination) {\r\n      await instance.render(destination);\r\n    }\r\n  };\r\n}\r\nasync function renderComponent(result, displayName, Component, props, slots = {}) {\r\n  if (isPromise(Component)) {\r\n    Component = await Component;\r\n  }\r\n  if (isFragmentComponent(Component)) {\r\n    return await renderFragmentComponent(result, slots);\r\n  }\r\n  props = normalizeProps(props);\r\n  if (isHTMLComponent(Component)) {\r\n    return await renderHTMLComponent(result, Component, props, slots);\r\n  }\r\n  if (isAstroComponentFactory(Component)) {\r\n    return renderAstroComponent(result, displayName, Component, props, slots);\r\n  }\r\n  return await renderFrameworkComponent(result, displayName, Component, props, slots);\r\n}\r\nfunction normalizeProps(props) {\r\n  if (props[\"class:list\"] !== void 0) {\r\n    const value = props[\"class:list\"];\r\n    delete props[\"class:list\"];\r\n    props[\"class\"] = clsx(props[\"class\"], value);\r\n    if (props[\"class\"] === \"\") {\r\n      delete props[\"class\"];\r\n    }\r\n  }\r\n  return props;\r\n}\r\nasync function renderComponentToString(result, displayName, Component, props, slots = {}, isPage = false, route) {\r\n  let str = \"\";\r\n  let renderedFirstPageChunk = false;\r\n  let head = \"\";\r\n  if (nonAstroPageNeedsHeadInjection(Component)) {\r\n    for (const headChunk of maybeRenderHead()) {\r\n      head += chunkToString(result, headChunk);\r\n    }\r\n  }\r\n  try {\r\n    const destination = {\r\n      write(chunk) {\r\n        if (isPage && !renderedFirstPageChunk) {\r\n          renderedFirstPageChunk = true;\r\n          if (!result.partial && !/<!doctype html/i.test(String(chunk))) {\r\n            const doctype = result.compressHTML ? \"<!DOCTYPE html>\" : \"<!DOCTYPE html>\\n\";\r\n            str += doctype + head;\r\n          }\r\n        }\r\n        if (chunk instanceof Response)\r\n          return;\r\n        str += chunkToString(result, chunk);\r\n      }\r\n    };\r\n    const renderInstance = await renderComponent(result, displayName, Component, props, slots);\r\n    await renderInstance.render(destination);\r\n  } catch (e) {\r\n    if (AstroError.is(e) && !e.loc) {\r\n      e.setLocation({\r\n        file: route?.component\r\n      });\r\n    }\r\n    throw e;\r\n  }\r\n  return str;\r\n}\r\nfunction nonAstroPageNeedsHeadInjection(pageComponent) {\r\n  return !!pageComponent?.[needsHeadRenderingSymbol];\r\n}\r\nexport {\r\n  renderComponent,\r\n  renderComponentToString\r\n};\r\n", "import { AstroJSX, isVNode } from \"../../jsx-runtime/index.js\";\r\nimport {\r\n  HTMLString,\r\n  escapeHTML,\r\n  markHTMLString,\r\n  renderToString,\r\n  spreadAttributes,\r\n  voidElementNames\r\n} from \"./index.js\";\r\nimport { renderComponentToString } from \"./render/component.js\";\r\nconst ClientOnlyPlaceholder = \"astro-client-only\";\r\nclass Skip {\r\n  constructor(vnode) {\r\n    this.vnode = vnode;\r\n    this.count = 0;\r\n  }\r\n  count;\r\n  increment() {\r\n    this.count++;\r\n  }\r\n  haveNoTried() {\r\n    return this.count === 0;\r\n  }\r\n  isCompleted() {\r\n    return this.count > 2;\r\n  }\r\n  static symbol = Symbol(\"astro:jsx:skip\");\r\n}\r\nlet originalConsoleError;\r\nlet consoleFilterRefs = 0;\r\nasync function renderJSX(result, vnode) {\r\n  switch (true) {\r\n    case vnode instanceof HTMLString:\r\n      if (vnode.toString().trim() === \"\") {\r\n        return \"\";\r\n      }\r\n      return vnode;\r\n    case typeof vnode === \"string\":\r\n      return markHTMLString(escapeHTML(vnode));\r\n    case typeof vnode === \"function\":\r\n      return vnode;\r\n    case (!vnode && vnode !== 0):\r\n      return \"\";\r\n    case Array.isArray(vnode):\r\n      return markHTMLString(\r\n        (await Promise.all(vnode.map((v) => renderJSX(result, v)))).join(\"\")\r\n      );\r\n  }\r\n  let skip;\r\n  if (vnode.props) {\r\n    if (vnode.props[Skip.symbol]) {\r\n      skip = vnode.props[Skip.symbol];\r\n    } else {\r\n      skip = new Skip(vnode);\r\n    }\r\n  } else {\r\n    skip = new Skip(vnode);\r\n  }\r\n  return renderJSXVNode(result, vnode, skip);\r\n}\r\nasync function renderJSXVNode(result, vnode, skip) {\r\n  if (isVNode(vnode)) {\r\n    switch (true) {\r\n      case !vnode.type: {\r\n        throw new Error(`Unable to render ${result.pathname} because it contains an undefined Component!\r\nDid you forget to import the component or is it possible there is a typo?`);\r\n      }\r\n      case vnode.type === Symbol.for(\"astro:fragment\"):\r\n        return renderJSX(result, vnode.props.children);\r\n      case vnode.type.isAstroComponentFactory: {\r\n        let props = {};\r\n        let slots = {};\r\n        for (const [key, value] of Object.entries(vnode.props ?? {})) {\r\n          if (key === \"children\" || value && typeof value === \"object\" && value[\"$$slot\"]) {\r\n            slots[key === \"children\" ? \"default\" : key] = () => renderJSX(result, value);\r\n          } else {\r\n            props[key] = value;\r\n          }\r\n        }\r\n        const str = await renderToString(result, vnode.type, props, slots);\r\n        if (str instanceof Response) {\r\n          throw str;\r\n        }\r\n        const html = markHTMLString(str);\r\n        return html;\r\n      }\r\n      case (!vnode.type && vnode.type !== 0):\r\n        return \"\";\r\n      case (typeof vnode.type === \"string\" && vnode.type !== ClientOnlyPlaceholder):\r\n        return markHTMLString(await renderElement(result, vnode.type, vnode.props ?? {}));\r\n    }\r\n    if (vnode.type) {\r\n      let extractSlots2 = function(child) {\r\n        if (Array.isArray(child)) {\r\n          return child.map((c) => extractSlots2(c));\r\n        }\r\n        if (!isVNode(child)) {\r\n          _slots.default.push(child);\r\n          return;\r\n        }\r\n        if (\"slot\" in child.props) {\r\n          _slots[child.props.slot] = [..._slots[child.props.slot] ?? [], child];\r\n          delete child.props.slot;\r\n          return;\r\n        }\r\n        _slots.default.push(child);\r\n      };\r\n      var extractSlots = extractSlots2;\r\n      if (typeof vnode.type === \"function\" && vnode.type[\"astro:renderer\"]) {\r\n        skip.increment();\r\n      }\r\n      if (typeof vnode.type === \"function\" && vnode.props[\"server:root\"]) {\r\n        const output2 = await vnode.type(vnode.props ?? {});\r\n        return await renderJSX(result, output2);\r\n      }\r\n      if (typeof vnode.type === \"function\") {\r\n        if (skip.haveNoTried() || skip.isCompleted()) {\r\n          useConsoleFilter();\r\n          try {\r\n            const output2 = await vnode.type(vnode.props ?? {});\r\n            let renderResult;\r\n            if (output2?.[AstroJSX]) {\r\n              renderResult = await renderJSXVNode(result, output2, skip);\r\n              return renderResult;\r\n            } else if (!output2) {\r\n              renderResult = await renderJSXVNode(result, output2, skip);\r\n              return renderResult;\r\n            }\r\n          } catch (e) {\r\n            if (skip.isCompleted()) {\r\n              throw e;\r\n            }\r\n            skip.increment();\r\n          } finally {\r\n            finishUsingConsoleFilter();\r\n          }\r\n        } else {\r\n          skip.increment();\r\n        }\r\n      }\r\n      const { children = null, ...props } = vnode.props ?? {};\r\n      const _slots = {\r\n        default: []\r\n      };\r\n      extractSlots2(children);\r\n      for (const [key, value] of Object.entries(props)) {\r\n        if (value[\"$$slot\"]) {\r\n          _slots[key] = value;\r\n          delete props[key];\r\n        }\r\n      }\r\n      const slotPromises = [];\r\n      const slots = {};\r\n      for (const [key, value] of Object.entries(_slots)) {\r\n        slotPromises.push(\r\n          renderJSX(result, value).then((output2) => {\r\n            if (output2.toString().trim().length === 0)\r\n              return;\r\n            slots[key] = () => output2;\r\n          })\r\n        );\r\n      }\r\n      await Promise.all(slotPromises);\r\n      props[Skip.symbol] = skip;\r\n      let output;\r\n      if (vnode.type === ClientOnlyPlaceholder && vnode.props[\"client:only\"]) {\r\n        output = await renderComponentToString(\r\n          result,\r\n          vnode.props[\"client:display-name\"] ?? \"\",\r\n          null,\r\n          props,\r\n          slots\r\n        );\r\n      } else {\r\n        output = await renderComponentToString(\r\n          result,\r\n          typeof vnode.type === \"function\" ? vnode.type.name : vnode.type,\r\n          vnode.type,\r\n          props,\r\n          slots\r\n        );\r\n      }\r\n      return markHTMLString(output);\r\n    }\r\n  }\r\n  return markHTMLString(`${vnode}`);\r\n}\r\nasync function renderElement(result, tag, { children, ...props }) {\r\n  return markHTMLString(\r\n    `<${tag}${spreadAttributes(props)}${markHTMLString(\r\n      (children == null || children == \"\") && voidElementNames.test(tag) ? `/>` : `>${children == null ? \"\" : await renderJSX(result, prerenderElementChildren(tag, children))}</${tag}>`\r\n    )}`\r\n  );\r\n}\r\nfunction prerenderElementChildren(tag, children) {\r\n  if (typeof children === \"string\" && (tag === \"style\" || tag === \"script\")) {\r\n    return markHTMLString(children);\r\n  } else {\r\n    return children;\r\n  }\r\n}\r\nfunction useConsoleFilter() {\r\n  consoleFilterRefs++;\r\n  if (!originalConsoleError) {\r\n    originalConsoleError = console.error;\r\n    try {\r\n      console.error = filteredConsoleError;\r\n    } catch (error) {\r\n    }\r\n  }\r\n}\r\nfunction finishUsingConsoleFilter() {\r\n  consoleFilterRefs--;\r\n}\r\nfunction filteredConsoleError(msg, ...rest) {\r\n  if (consoleFilterRefs > 0 && typeof msg === \"string\") {\r\n    const isKnownReactHookError = msg.includes(\"Warning: Invalid hook call.\") && msg.includes(\"https://reactjs.org/link/invalid-hook-call\");\r\n    if (isKnownReactHookError)\r\n      return;\r\n  }\r\n  originalConsoleError(msg, ...rest);\r\n}\r\nexport {\r\n  renderJSX\r\n};\r\n", "import { parse, serialize } from \"cookie\";\r\nimport { AstroError, AstroErrorData } from \"../errors/index.js\";\r\nconst DELETED_EXPIRATION = /* @__PURE__ */ new Date(0);\r\nconst DELETED_VALUE = \"deleted\";\r\nconst responseSentSymbol = Symbol.for(\"astro.responseSent\");\r\nclass AstroCookie {\r\n  constructor(value) {\r\n    this.value = value;\r\n  }\r\n  json() {\r\n    if (this.value === void 0) {\r\n      throw new Error(`Cannot convert undefined to an object.`);\r\n    }\r\n    return JSON.parse(this.value);\r\n  }\r\n  number() {\r\n    return Number(this.value);\r\n  }\r\n  boolean() {\r\n    if (this.value === \"false\")\r\n      return false;\r\n    if (this.value === \"0\")\r\n      return false;\r\n    return Boolean(this.value);\r\n  }\r\n}\r\nclass AstroCookies {\r\n  #request;\r\n  #requestValues;\r\n  #outgoing;\r\n  #consumed;\r\n  constructor(request) {\r\n    this.#request = request;\r\n    this.#requestValues = null;\r\n    this.#outgoing = null;\r\n    this.#consumed = false;\r\n  }\r\n  /**\r\n   * Astro.cookies.delete(key) is used to delete a cookie. Using this method will result\r\n   * in a Set-Cookie header added to the response.\r\n   * @param key The cookie to delete\r\n   * @param options Options related to this deletion, such as the path of the cookie.\r\n   */\r\n  delete(key, options) {\r\n    const serializeOptions = {\r\n      expires: DELETED_EXPIRATION\r\n    };\r\n    if (options?.domain) {\r\n      serializeOptions.domain = options.domain;\r\n    }\r\n    if (options?.path) {\r\n      serializeOptions.path = options.path;\r\n    }\r\n    this.#ensureOutgoingMap().set(key, [\r\n      DELETED_VALUE,\r\n      serialize(key, DELETED_VALUE, serializeOptions),\r\n      false\r\n    ]);\r\n  }\r\n  /**\r\n   * Astro.cookies.get(key) is used to get a cookie value. The cookie value is read from the\r\n   * request. If you have set a cookie via Astro.cookies.set(key, value), the value will be taken\r\n   * from that set call, overriding any values already part of the request.\r\n   * @param key The cookie to get.\r\n   * @returns An object containing the cookie value as well as convenience methods for converting its value.\r\n   */\r\n  get(key, options = void 0) {\r\n    if (this.#outgoing?.has(key)) {\r\n      let [serializedValue, , isSetValue] = this.#outgoing.get(key);\r\n      if (isSetValue) {\r\n        return new AstroCookie(serializedValue);\r\n      } else {\r\n        return void 0;\r\n      }\r\n    }\r\n    const values = this.#ensureParsed(options);\r\n    if (key in values) {\r\n      const value = values[key];\r\n      return new AstroCookie(value);\r\n    }\r\n  }\r\n  /**\r\n   * Astro.cookies.has(key) returns a boolean indicating whether this cookie is either\r\n   * part of the initial request or set via Astro.cookies.set(key)\r\n   * @param key The cookie to check for.\r\n   * @returns\r\n   */\r\n  has(key, options = void 0) {\r\n    if (this.#outgoing?.has(key)) {\r\n      let [, , isSetValue] = this.#outgoing.get(key);\r\n      return isSetValue;\r\n    }\r\n    const values = this.#ensureParsed(options);\r\n    return !!values[key];\r\n  }\r\n  /**\r\n   * Astro.cookies.set(key, value) is used to set a cookie's value. If provided\r\n   * an object it will be stringified via JSON.stringify(value). Additionally you\r\n   * can provide options customizing how this cookie will be set, such as setting httpOnly\r\n   * in order to prevent the cookie from being read in client-side JavaScript.\r\n   * @param key The name of the cookie to set.\r\n   * @param value A value, either a string or other primitive or an object.\r\n   * @param options Options for the cookie, such as the path and security settings.\r\n   */\r\n  set(key, value, options) {\r\n    if (this.#consumed) {\r\n      const warning = new Error(\r\n        \"Astro.cookies.set() was called after the cookies had already been sent to the browser.\\nThis may have happened if this method was called in an imported component.\\nPlease make sure that Astro.cookies.set() is only called in the frontmatter of the main page.\"\r\n      );\r\n      warning.name = \"Warning\";\r\n      console.warn(warning);\r\n    }\r\n    let serializedValue;\r\n    if (typeof value === \"string\") {\r\n      serializedValue = value;\r\n    } else {\r\n      let toStringValue = value.toString();\r\n      if (toStringValue === Object.prototype.toString.call(value)) {\r\n        serializedValue = JSON.stringify(value);\r\n      } else {\r\n        serializedValue = toStringValue;\r\n      }\r\n    }\r\n    const serializeOptions = {};\r\n    if (options) {\r\n      Object.assign(serializeOptions, options);\r\n    }\r\n    this.#ensureOutgoingMap().set(key, [\r\n      serializedValue,\r\n      serialize(key, serializedValue, serializeOptions),\r\n      true\r\n    ]);\r\n    if (this.#request[responseSentSymbol]) {\r\n      throw new AstroError({\r\n        ...AstroErrorData.ResponseSentError\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * Astro.cookies.header() returns an iterator for the cookies that have previously\r\n   * been set by either Astro.cookies.set() or Astro.cookies.delete().\r\n   * This method is primarily used by adapters to set the header on outgoing responses.\r\n   * @returns\r\n   */\r\n  *headers() {\r\n    if (this.#outgoing == null)\r\n      return;\r\n    for (const [, value] of this.#outgoing) {\r\n      yield value[1];\r\n    }\r\n  }\r\n  /**\r\n   * Behaves the same as AstroCookies.prototype.headers(),\r\n   * but allows a warning when cookies are set after the instance is consumed.\r\n   */\r\n  static consume(cookies) {\r\n    cookies.#consumed = true;\r\n    return cookies.headers();\r\n  }\r\n  #ensureParsed(options = void 0) {\r\n    if (!this.#requestValues) {\r\n      this.#parse(options);\r\n    }\r\n    if (!this.#requestValues) {\r\n      this.#requestValues = {};\r\n    }\r\n    return this.#requestValues;\r\n  }\r\n  #ensureOutgoingMap() {\r\n    if (!this.#outgoing) {\r\n      this.#outgoing = /* @__PURE__ */ new Map();\r\n    }\r\n    return this.#outgoing;\r\n  }\r\n  #parse(options = void 0) {\r\n    const raw = this.#request.headers.get(\"cookie\");\r\n    if (!raw) {\r\n      return;\r\n    }\r\n    this.#requestValues = parse(raw, options);\r\n  }\r\n}\r\nexport {\r\n  AstroCookies\r\n};\r\n", "import { AstroCookies } from \"./cookies.js\";\r\nconst astroCookiesSymbol = Symbol.for(\"astro.cookies\");\r\nfunction attachCookiesToResponse(response, cookies) {\r\n  Reflect.set(response, astroCookiesSymbol, cookies);\r\n}\r\nfunction responseHasCookies(response) {\r\n  return Reflect.has(response, astroCookiesSymbol);\r\n}\r\nfunction getFromResponse(response) {\r\n  let cookies = Reflect.get(response, astroCookiesSymbol);\r\n  if (cookies != null) {\r\n    return cookies;\r\n  } else {\r\n    return void 0;\r\n  }\r\n}\r\nfunction* getSetCookiesFromResponse(response) {\r\n  const cookies = getFromResponse(response);\r\n  if (!cookies) {\r\n    return [];\r\n  }\r\n  for (const headerValue of AstroCookies.consume(cookies)) {\r\n    yield headerValue;\r\n  }\r\n  return [];\r\n}\r\nexport {\r\n  attachCookiesToResponse,\r\n  getSetCookiesFromResponse,\r\n  responseHasCookies\r\n};\r\n", "import { normalizeTheLocale, toCodes } from \"../../i18n/index.js\";\r\nimport { AstroError, AstroErrorData } from \"../errors/index.js\";\r\nimport { getParamsAndProps } from \"./params-and-props.js\";\r\nconst clientLocalsSymbol = Symbol.for(\"astro.locals\");\r\nasync function createRenderContext(options) {\r\n  const request = options.request;\r\n  const pathname = options.pathname ?? new URL(request.url).pathname;\r\n  const [params, props] = await getParamsAndProps({\r\n    mod: options.mod,\r\n    route: options.route,\r\n    routeCache: options.env.routeCache,\r\n    pathname,\r\n    logger: options.env.logger,\r\n    ssr: options.env.ssr\r\n  });\r\n  const context = {\r\n    ...options,\r\n    pathname,\r\n    params,\r\n    props,\r\n    locales: options.locales,\r\n    routing: options.routing,\r\n    defaultLocale: options.defaultLocale\r\n  };\r\n  Object.defineProperty(context, \"locals\", {\r\n    enumerable: true,\r\n    get() {\r\n      return Reflect.get(request, clientLocalsSymbol);\r\n    },\r\n    set(val) {\r\n      if (typeof val !== \"object\") {\r\n        throw new AstroError(AstroErrorData.LocalsNotAnObject);\r\n      } else {\r\n        Reflect.set(request, clientLocalsSymbol, val);\r\n      }\r\n    }\r\n  });\r\n  return context;\r\n}\r\nfunction parseLocale(header) {\r\n  if (header === \"*\") {\r\n    return [{ locale: header, qualityValue: void 0 }];\r\n  }\r\n  const result = [];\r\n  const localeValues = header.split(\",\").map((str) => str.trim());\r\n  for (const localeValue of localeValues) {\r\n    const split = localeValue.split(\";\").map((str) => str.trim());\r\n    const localeName = split[0];\r\n    const qualityValue = split[1];\r\n    if (!split) {\r\n      continue;\r\n    }\r\n    if (qualityValue && qualityValue.startsWith(\"q=\")) {\r\n      const qualityValueAsFloat = Number.parseFloat(qualityValue.slice(\"q=\".length));\r\n      if (Number.isNaN(qualityValueAsFloat) || qualityValueAsFloat > 1) {\r\n        result.push({\r\n          locale: localeName,\r\n          qualityValue: void 0\r\n        });\r\n      } else {\r\n        result.push({\r\n          locale: localeName,\r\n          qualityValue: qualityValueAsFloat\r\n        });\r\n      }\r\n    } else {\r\n      result.push({\r\n        locale: localeName,\r\n        qualityValue: void 0\r\n      });\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction sortAndFilterLocales(browserLocaleList, locales) {\r\n  const normalizedLocales = toCodes(locales).map(normalizeTheLocale);\r\n  return browserLocaleList.filter((browserLocale) => {\r\n    if (browserLocale.locale !== \"*\") {\r\n      return normalizedLocales.includes(normalizeTheLocale(browserLocale.locale));\r\n    }\r\n    return true;\r\n  }).sort((a, b) => {\r\n    if (a.qualityValue && b.qualityValue) {\r\n      if (a.qualityValue > b.qualityValue) {\r\n        return -1;\r\n      } else if (a.qualityValue < b.qualityValue) {\r\n        return 1;\r\n      }\r\n    }\r\n    return 0;\r\n  });\r\n}\r\nfunction computePreferredLocale(request, locales) {\r\n  const acceptHeader = request.headers.get(\"Accept-Language\");\r\n  let result = void 0;\r\n  if (acceptHeader) {\r\n    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);\r\n    const firstResult = browserLocaleList.at(0);\r\n    if (firstResult && firstResult.locale !== \"*\") {\r\n      for (const currentLocale of locales) {\r\n        if (typeof currentLocale === \"string\") {\r\n          if (normalizeTheLocale(currentLocale) === normalizeTheLocale(firstResult.locale)) {\r\n            result = currentLocale;\r\n          }\r\n        } else {\r\n          for (const currentCode of currentLocale.codes) {\r\n            if (normalizeTheLocale(currentCode) === normalizeTheLocale(firstResult.locale)) {\r\n              result = currentLocale.path;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction computePreferredLocaleList(request, locales) {\r\n  const acceptHeader = request.headers.get(\"Accept-Language\");\r\n  let result = [];\r\n  if (acceptHeader) {\r\n    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);\r\n    if (browserLocaleList.length === 1 && browserLocaleList.at(0).locale === \"*\") {\r\n      return locales.map((locale) => {\r\n        if (typeof locale === \"string\") {\r\n          return locale;\r\n        } else {\r\n          return locale.codes.at(0);\r\n        }\r\n      });\r\n    } else if (browserLocaleList.length > 0) {\r\n      for (const browserLocale of browserLocaleList) {\r\n        for (const loopLocale of locales) {\r\n          if (typeof loopLocale === \"string\") {\r\n            if (normalizeTheLocale(loopLocale) === normalizeTheLocale(browserLocale.locale)) {\r\n              result.push(loopLocale);\r\n            }\r\n          } else {\r\n            for (const code of loopLocale.codes) {\r\n              if (code === browserLocale.locale) {\r\n                result.push(loopLocale.path);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction computeCurrentLocale(request, locales, routingStrategy, defaultLocale) {\r\n  const requestUrl = new URL(request.url);\r\n  for (const segment of requestUrl.pathname.split(\"/\")) {\r\n    for (const locale of locales) {\r\n      if (typeof locale === \"string\") {\r\n        if (normalizeTheLocale(locale) === normalizeTheLocale(segment)) {\r\n          return locale;\r\n        }\r\n      } else {\r\n        if (locale.path === segment) {\r\n          return locale.codes.at(0);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (routingStrategy === \"prefix-other-locales\") {\r\n    return defaultLocale;\r\n  }\r\n  return void 0;\r\n}\r\nexport {\r\n  computeCurrentLocale,\r\n  computePreferredLocale,\r\n  computePreferredLocaleList,\r\n  createRenderContext,\r\n  parseLocale\r\n};\r\n", "import { renderEndpoint } from \"../../runtime/server/index.js\";\r\nimport { ASTRO_VERSION } from \"../constants.js\";\r\nimport { AstroCookies, attachCookiesToResponse } from \"../cookies/index.js\";\r\nimport { AstroError, AstroErrorData } from \"../errors/index.js\";\r\nimport { callMiddleware } from \"../middleware/callMiddleware.js\";\r\nimport {\r\n  computeCurrentLocale,\r\n  computePreferredLocale,\r\n  computePreferredLocaleList\r\n} from \"../render/context.js\";\r\nimport {} from \"../render/index.js\";\r\nconst clientAddressSymbol = Symbol.for(\"astro.clientAddress\");\r\nconst clientLocalsSymbol = Symbol.for(\"astro.locals\");\r\nfunction createAPIContext({\r\n  request,\r\n  params,\r\n  site,\r\n  props,\r\n  adapterName,\r\n  locales,\r\n  routingStrategy,\r\n  defaultLocale\r\n}) {\r\n  let preferredLocale = void 0;\r\n  let preferredLocaleList = void 0;\r\n  let currentLocale = void 0;\r\n  const context = {\r\n    cookies: new AstroCookies(request),\r\n    request,\r\n    params,\r\n    site: site ? new URL(site) : void 0,\r\n    generator: `Astro v${ASTRO_VERSION}`,\r\n    props,\r\n    redirect(path, status) {\r\n      return new Response(null, {\r\n        status: status || 302,\r\n        headers: {\r\n          Location: path\r\n        }\r\n      });\r\n    },\r\n    get preferredLocale() {\r\n      if (preferredLocale) {\r\n        return preferredLocale;\r\n      }\r\n      if (locales) {\r\n        preferredLocale = computePreferredLocale(request, locales);\r\n        return preferredLocale;\r\n      }\r\n      return void 0;\r\n    },\r\n    get preferredLocaleList() {\r\n      if (preferredLocaleList) {\r\n        return preferredLocaleList;\r\n      }\r\n      if (locales) {\r\n        preferredLocaleList = computePreferredLocaleList(request, locales);\r\n        return preferredLocaleList;\r\n      }\r\n      return void 0;\r\n    },\r\n    get currentLocale() {\r\n      if (currentLocale) {\r\n        return currentLocale;\r\n      }\r\n      if (locales) {\r\n        currentLocale = computeCurrentLocale(request, locales, routingStrategy, defaultLocale);\r\n      }\r\n      return currentLocale;\r\n    },\r\n    url: new URL(request.url),\r\n    get clientAddress() {\r\n      if (clientAddressSymbol in request) {\r\n        return Reflect.get(request, clientAddressSymbol);\r\n      }\r\n      if (adapterName) {\r\n        throw new AstroError({\r\n          ...AstroErrorData.ClientAddressNotAvailable,\r\n          message: AstroErrorData.ClientAddressNotAvailable.message(adapterName)\r\n        });\r\n      } else {\r\n        throw new AstroError(AstroErrorData.StaticClientAddressNotAvailable);\r\n      }\r\n    },\r\n    get locals() {\r\n      let locals = Reflect.get(request, clientLocalsSymbol);\r\n      if (locals === void 0) {\r\n        locals = {};\r\n        Reflect.set(request, clientLocalsSymbol, locals);\r\n      }\r\n      if (typeof locals !== \"object\") {\r\n        throw new AstroError(AstroErrorData.LocalsNotAnObject);\r\n      }\r\n      return locals;\r\n    },\r\n    // We define a custom property, so we can check the value passed to locals\r\n    set locals(val) {\r\n      if (typeof val !== \"object\") {\r\n        throw new AstroError(AstroErrorData.LocalsNotAnObject);\r\n      } else {\r\n        Reflect.set(request, clientLocalsSymbol, val);\r\n      }\r\n    }\r\n  };\r\n  return context;\r\n}\r\nasync function callEndpoint(mod, env, ctx, onRequest) {\r\n  const context = createAPIContext({\r\n    request: ctx.request,\r\n    params: ctx.params,\r\n    props: ctx.props,\r\n    site: env.site,\r\n    adapterName: env.adapterName,\r\n    routingStrategy: ctx.routing,\r\n    defaultLocale: ctx.defaultLocale,\r\n    locales: ctx.locales\r\n  });\r\n  let response;\r\n  if (onRequest) {\r\n    response = await callMiddleware(onRequest, context, async () => {\r\n      return await renderEndpoint(mod, context, env.ssr, env.logger);\r\n    });\r\n  } else {\r\n    response = await renderEndpoint(mod, context, env.ssr, env.logger);\r\n  }\r\n  attachCookiesToResponse(response, context.cookies);\r\n  return response;\r\n}\r\nexport {\r\n  callEndpoint,\r\n  createAPIContext\r\n};\r\n", "import { defineMiddleware } from \"./index.js\";\r\nfunction sequence(...handlers) {\r\n  const filtered = handlers.filter((h) => !!h);\r\n  const length = filtered.length;\r\n  if (!length) {\r\n    const handler = defineMiddleware((context, next) => {\r\n      return next();\r\n    });\r\n    return handler;\r\n  }\r\n  return defineMiddleware((context, next) => {\r\n    return applyHandle(0, context);\r\n    function applyHandle(i, handleContext) {\r\n      const handle = filtered[i];\r\n      const result = handle(handleContext, async () => {\r\n        if (i < length - 1) {\r\n          return applyHandle(i + 1, handleContext);\r\n        } else {\r\n          return next();\r\n        }\r\n      });\r\n      return result;\r\n    }\r\n  });\r\n}\r\nexport {\r\n  sequence\r\n};\r\n", "import { createAPIContext } from \"../endpoint/index.js\";\r\nimport { sequence } from \"./sequence.js\";\r\nfunction defineMiddleware(fn) {\r\n  return fn;\r\n}\r\nfunction createContext({ request, params, userDefinedLocales = [] }) {\r\n  return createAPIContext({\r\n    request,\r\n    params: params ?? {},\r\n    props: {},\r\n    site: void 0,\r\n    locales: userDefinedLocales,\r\n    defaultLocale: void 0,\r\n    routingStrategy: void 0\r\n  });\r\n}\r\nfunction isLocalsSerializable(value) {\r\n  let type = typeof value;\r\n  let plainObject = true;\r\n  if (type === \"object\" && isPlainObject(value)) {\r\n    for (const [, nestedValue] of Object.entries(value)) {\r\n      if (!isLocalsSerializable(nestedValue)) {\r\n        plainObject = false;\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    plainObject = false;\r\n  }\r\n  let result = value === null || type === \"string\" || type === \"number\" || type === \"boolean\" || Array.isArray(value) || plainObject;\r\n  return result;\r\n}\r\nfunction isPlainObject(value) {\r\n  if (typeof value !== \"object\" || value === null)\r\n    return false;\r\n  let proto = Object.getPrototypeOf(value);\r\n  if (proto === null)\r\n    return true;\r\n  let baseProto = proto;\r\n  while (Object.getPrototypeOf(baseProto) !== null) {\r\n    baseProto = Object.getPrototypeOf(baseProto);\r\n  }\r\n  return proto === baseProto;\r\n}\r\nfunction trySerializeLocals(value) {\r\n  if (isLocalsSerializable(value)) {\r\n    return JSON.stringify(value);\r\n  } else {\r\n    throw new Error(\"The passed value can't be serialized.\");\r\n  }\r\n}\r\nexport {\r\n  createContext,\r\n  defineMiddleware,\r\n  sequence,\r\n  trySerializeLocals\r\n};\r\n"],
  "mappings": "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",
  "names": ["parse", "serialize", "decode", "_a", "_a", "clientLocalsSymbol"]
}
